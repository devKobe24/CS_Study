# 3-2

---

## 명령어의 구조 🧑🏻‍💻

---

## 핵심 키워드

- 명령어
- 연산 코드
- 오퍼랜드
- 주소 지정 방식

**명령어의 구조와 주소 지정 방식을 학습하며 명령어의 생김새와 작동 원리를 이해합니다.**

---

## 연산 코드와 오퍼랜드 🧑🏻‍💻

기계어나 어셈블리어를 이루는 하나하나가 명령어입니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A91.png?raw=true)

과연 명령어 하나 하나는 어떻게 생겼을까요?

명령어의 구조는 예를 들어 다음과 같습니다.

- "학생들, 다음 주까지 과제를 제출하세요."
- "영수야, 방 좀 치워 줘!"
- "댕댕아, 이거 물어와!"

평소에 누군가에게 명령을 할 때 사용하는 그 구조를 그대로 따른다고 생각하시면 됩니다.

**컴퓨터 내부에 있는 명령어도 마찬가지 입니다.**

`무엇을 대상으로, 무엇을 수행하라` 라는 형식으로 명령어가 만들어져 있습니다.

즉, 위와 같은 형식으로 명령어가 구성되어 있다는 뜻 입니다.

조금 더 자세하게 알아보도록 하겠습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A92.png?raw=true)

위 그림과 같이 명령어가 구성되어 있습니다.

1. "더해라 100과 120을"
2. "빼라 메모리 32번지 안의 값과 메모리 32번지 안의 값을"
3. "저장해라 10을 메모리 128번지에"

**위 1,2,3은 모두 명령어의 구조를 띄고 있습니다**

자세히 한 번 봐보겠습니다.

각각의 명령어에서 보면 다음과 같이 나뉘어 집니다.

위 그림에서 보면 색칠된 부분.

- 더해라
- 빼라
- 저장해라

위 부분은 "수행할 연산"을 나타냅니다. -> 명령의 '작동'

- 100과
- 메모리 32번지 안의 값과
- 10을

위 부분은 "무엇을 대상으로" 해당 연산을 수행할지 나와있습니다.

조금 더 자세하게는 "연산에 사용될 데이터" 혹은 "연산에 사용될 데이터가 저장된 위치"가 명시된 것을 알 수 있습니다.

위와 같은 형태를 띄고 있는 것이 우리의 컴퓨터를 동작시키는 명령어의 형태라고 보시면 됩니다.

이것을 조금 더 일반적으로 표현해 보겠습니다.

아래 그림에서 색칠된 부분, 즉 연산 코드가 담기는 영역을 **"연산 코드 필드"** 라고 부르고, 색칠되지 않은 부분, 즉 오퍼랜드가 담기는 영역을 **"오퍼랜드 필드"** 라고 합니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A93.png?raw=true)

**"명령어"**는 크게 **"연산 코드(operation code)"** 와 **"오퍼랜드(operand)"**로 이루어져 있다고 표현합니다.

**연산 코드는 "연산자", 오퍼랜드는 "피연산자"라고도 부릅니다.**

**"연산 코드"** 는 위에서 설명한 바와 같이 **"수행할 연산을 담고 있는것을 의미"** 합니다. 

**"오퍼랜드"** 는 위에서 설명한 바와 같이 **"연산에 사용될 데이터가 저장된 위치"**

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A94.png?raw=true)

어셈블리어나 기계어는 전부 명령어로 이루어져있습니다.

결국 기계어, 어셈블리어도 명령어입니다.

다시말해, 기계어와 어셈블리어는 연산 코드와 오퍼랜드로 이루어져있다고 말할 수 있습니다.

위 그림에서 붉은 글자는 **"연산 코드"** 에 해당합니다.

오른쪽에 검은 글자는 **"오퍼랜드"** 에 해당합니다.

---

### 오퍼랜드 🧑🏻‍💻

**"연산에 사용될 데이터" 혹은 "연산에 사용될 데이터가 저장된 위치"를 뜻합니다.**

그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있습니다.

**오퍼랜드가 저장되는 공간, 즉 오퍼랜드 필드에는 "연산에 사용될 데이터" 또는 "연산에 사용될 데이터가 저장된 위치"가 저장된다고는 하지만 사실은 "연산에 사용될 데이터가 저장된 위치"가 훨씬 더 자주 저장됩니다.**

위와 같은 이유로 오퍼랜드가 담기는 공간 즉, 오퍼랜드 필드를 **"주소 필드"** 라고 부르기도 합니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A95.png?raw=true)

위 그림에서 보이는 어셈블리어를 보면 알 수 있다시피 오퍼랜드의 갯수가 **두 개인 경우, 한 개인 경우 혹은 없는 경우도 있습니다.**

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A96.png?raw=true)
이처럼 오퍼랜드의 갯수는 여러 개가 될 수도 있고 하나도 없을 수도 있습니다.

오퍼랜드가 없는 경우는 "0-주소 명령어"

오퍼랜드가 한 개인 경우는 "1-주소 명령어"

오퍼랜드가 두 개인 경우는 "2-주소 명령어"

오퍼랜드가 세 개인 경우는 "3-주소 명령어"

이렇게 부릅니다. 여기서 중요한 것은 용어가 아닙니다.

**"오퍼랜드가 없는 경우도 있고 하나 이상인 경우도 있다"** 라는 점 입니다. 이 부분이 중요합니다.

---

### 연산 코드 🧑🏻‍💻

이번에는 연산 코드에 대해서 알아보도록 하겠습니다.

위에서 잠시 본 예시에서 "더해라", "빼라", "저장해라"에 해당하는 부분이 연산 코드입니다.

위에서 설명했듯이 연산 코드는 **수행할 연산을 담고 있는것을 의미"** 합니다.

"수행할 연산을 담고 있다" 라는 것은 무엇을 의미하는지 조금 더 자세하게 알아보겠습니다.

연산 코드가 담고 있는 내용은 CPU마다 다양합니다.

CPU마다 각기 다른 연산 코드를 가지고 있습니다.

이 부분에 대해서는 CPU를 학습 할 때 다루겠습니다.

즉, CPU마다 가지고 있는 연산 코드의 종류나 갯수는 다양합니다.

대부분의 전공서가 기술하고 있는 통상의 연산 코드의 종류에는 크게 네 가지가 있습니다.

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

**👉 대표적인 연산 코드의 종류**

이 부분은 외우려고 하지말고 '이러한 유형이 있다' 라고만 이해하면 됩니다.

앞서 설명했다시피 **연산코드의 종류나 갯수는 CPU의 종류마다 다르기 때문에** 아래에서 설명하는 내용을 외우는 건 의미가 없습니다.

다시 말해, **유형을 아는 것이 중요합니다.**

1️⃣ 먼저, **데이터 전송** 연산코드의 종류에 대해서 알아보겠습니다.
- MOVE : 데이터를 옮겨라.
- STORE : 메모리에 저장하라.
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라

![](https://github.com/devKobe24/images/blob/main/%E1%84%92%E1%85%A9%E1%86%AB%E1%84%80%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8.png?raw=true)
스택은 중요한 자료구조 중 하나 입니다.

한 쪽 끝이 막혀있는 통과 같은 자료구조를 스택이라고 합니다.

이 통에 데이터가 하나씩 차곡 차곡 쌓인다고 가정을 해봅시다.

그렇다면 이 통에서 데이터가 하나씩 빠질 때 어떤 데이터가 가장 먼저 빠질까요?

`5 -> 4 -> 3 -> 2 -> 1` 이 순서로 빠질거에요.

즉, 나중에 들어간 데이터가 먼저 나오게 되는 자료구조에요.

LIFO(Last In, First Out) 구조 입니다.

연산 코드에서 PUSH는 '한 쪽 끝이 막혀있는 통과 같은 저장 공간에 데이터를 밀어 넣어라' 라는 뜻 입니다.

POP은 '한 쪽 끝이 막혀있는 통과 같은 저장 공간에 데이터를 빼내라' 라는 뜻의 연산 코드라고 보시면됩니다.

이 스택은 비단 컴퓨터 구조, 운영 체제 뿐만 아니라 다양한 분야에서 언급되는 자료구조 이므로 잘 알아두는 것이 좋습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%92%E1%85%A9%E1%86%AB%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8F%E1%85%B2.png?raw=true)

스택과 비슷한 자료 구조로 큐라는 자료 구조가 있습니다.

큐는 스택과 달리 양쪽 끝이 뚫혀 있는 통과 같은 자료 구조 입니다.

그렇기 때문에 먼저 들어간 데이터가 먼저 나오게 됩니다.

FIFO(Fist In, First Out) 구조 입니다.

가령 데이터를 `5 -> 4 -> 3 -> 2 -> 1` 순서로 저장을 했다면 `5 -> 4 -> 3 -> 2 -> 1` 순서로 빠져나갈 것 입니다.

2️⃣ **산술/논리 연산**

- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라

3️⃣ **제어 흐름 변경**
특정 메모리 주소로 실행의 순서를 바꾸는 것

- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 떄 저장했던 주소로 돌아가라

4️⃣ **입출력 제어**

- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

---

## 명령어 주소 지정 방식 🧑🏻‍💻

![](https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8B%E1%85%B4%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A93.png?raw=true)
위에서 설명한 바와 같이 오퍼랜드에는 "연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치가 저장된다"고 하였습니다.

덧붙여 설명하자면 "연산에 사용될 데이터가 저장된 위치"가 오퍼랜드에 더 많이 저장된가고 설명하였습니다.

그래서 오퍼랜드가 담기는 이 공간, 오퍼랜드 필드를 "주소필드"라고 부르기도 한다고 설명하였습니다.

여기서 드는 의문점이 있을것입니다.

**'왜 굳이 위치를 사용할까요?? 🤔'**

그냥 연산에 사용될 데이터를 오퍼랜드에 명시를 해주면 조금 더 쉽지 않을까요??

**이는 명령어 길이 때문입니다.**

하나의 명령어가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m비트라고 가정해 봅시다.

이때 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m비트가 됩니다.

2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아질것입니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A81.png?raw=true)

**이것은 명령어 내에서 나타낼 수 있는 데이터의 크기가 제한되기 때문입니다.**

예를 들어, 명령어의 크기가 16bit라고 생각해봅시다.

그 16bit 중 연산 코드에 사용되는 크기가 4bit 라고 가정을 해보겠습니다.

그리고 2주소 명령어라서 오퍼랜드가 2개 있다고 가정을 해보겠습니다.

그렇다면 각각의 오퍼랜드는 6bit씩의 크기를 가질 수 있습니다.

그러면 하나의 오퍼랜드로 데이터를 표현할 수 있는 데이터의 크기는 2⁶(64) 밖에 없습니다.

6bit로 표현할 수 있는 데이터의 수는 2⁶(64)개 이기 때문입니다.

생각 외로 너무 작습니다.

그런데 오퍼랜드가 더 많아지면 표현할 수 있는 데이터의 수는 더 줄어듭니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A82.png?raw=true)

예를 들어 16bit 크기의 명령어가 있고 연산 코드가 4bit을 차지한다고 가정해봅시다.

그리고 3주소 명령어라서 오퍼랜드가 3개가 있다고 가정을 해보겠습니다

그렇다면 각각의 오퍼랜드는 4bit씩의 크기를 가질 수 있습니다.

그러면 하나의 오퍼랜드로 데이터를 표현할 수 있는 데이터의 크기는 2⁴(16) 밖에 없습니다.

4bit으로 표현할 수 있는 데이터의 수는 2⁴(16)개 이기 때문입니다.

만약 하나의 오퍼랜드에 1,000 또는 50,000이라는 숫자를 표현하고 싶을 경우에는 어떻게 할까요?

오퍼랜드에 직접적으로 숫자를 써넣어야 했다면 표현이 불가능 할겁니다.

하지만 이런 상황에서 **메모리 주소를 입력을 할 경우에는 표현 할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지게 됩니다.**

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A83.png?raw=true)

예를 들어서 명령어 한 번지에 16bit를 저장할 수 있다고 가정을 해봅시다.

위 그림에서 보다시피 **"10번지"** 에 저장된 위치를 명시를 하게되면 오퍼랜드 필드로 표현할 수 있는 데이터의 크기는  2¹⁶개가 됩니다.

위와 같은 이유 때문에 다시 말해 표현 할 수 있는 정보의 크기가 제한 받지 않도록 하기 위해서 오퍼랜드 필드에 연산에 사용되는 데이터가 저장되는 위치 이를테면 메모리 주소라던지 레지스터라던지 이런것들을 명시하는 것 입니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A84.png?raw=true)

위 그림과 같이 레지스터 이름을 명시할 때도 마찬가지 입니다.

이 경우 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커집니다.

여기서 알아야 하는 용어가 있습니다.

**👉 유효 주소(effective address)**

유효 주소라는 개념이 있습니다.

유효 주소란 **연산에 사용할 데이터가 저장된 위치**를 유효 주소라고 합니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A83.png?raw=true)

예를 들어 위 그림에서 연산 코드가 사용될 데이터 코드는 어디에 저장되어 있을까요??

10번지에 저장되어 있습니다.

즉, 위 그림의 영역에 유효 주소는 10번지가 되는 것 입니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A84.png?raw=true)

마찬가지로 레지스터에 연산에 사용할 데이터가 저장되어있는 위 그림에서도 연산에 사용할 데이터가 R1이라는 레지스터에 저장이 되어 있기 때문에 유효주소는 R1 레지스터가 되는 것 입니다.

**이렇게 연산에 사용할 데이터가 저장된 위치를 유효주소라고 합니다.**

여기까지 이해하셨다면 이 오퍼랜드 필드에 "레지스터" 혹은 "메모리 주소"가 아니면 아에 "연산 코드에 사용될 데이터 직접적으로" 담길 수 있다는 것을 이해하셨을 겁니다.

CPU 입장에서는 연산에 사용될 데이터가 "메모리 주소" 또는 "레지스터" 혹은 "직접적으로 명시"되어 있던간에 **"연산에 사용될 데이터들을 잘 찾아서 실행을 시킬 수 있어야 합니다"**

그 방법이 **"명령어 주소 지정 방식"** 입니다.

다시 말해 "연산에 사용할 데이터가 저장된 위치를 찾는 방법"이 "명령어 주소 지정 방식"이라고 보면 됩니다.

달리 말하면 "유효 주소를 찾는 방법"이라고도 합니다.

그리고 "다양한 명령어 주소 지정 방식들"이 존재합니다.

"다양한 명령어 주소 지정 방식들"이 존재한다는 말은 명령어에 사용될 데이터가 어디에 저장되어 있는지 판단할 수 있는 여러가지 방법들이 있다는 의미입니다.

물론 이 지정 방식도 CPU 마다 차이가 있습니다.

지금부터 대부분의 전공서들이 공통적으로 기술하고 있는 가장 대표적인 명령어 주소 지정방식에 대해서 알아보겠습니다.

1️⃣ **즉시 주소 지정 방식(immediate addressing mode)**
- 연산에 사용될 데이터를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태의 주소 지정 방식
- 연산에 사용할 데이터 크기가 작아질 수 있지만, 빠름
    - 그 이유는 연산에 사용할 데이터를 메모리나 레지스터로 부터 찾는 과정이 없기 때문에 이하 설명할 주소 지정 방식들보다 빠릅니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%B3%E1%86%A8%E1%84%89%E1%85%B5%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8.png?raw=true)

앞서 설명했다시피 이러한 방식에는 문제점이 있습니다.

그 문제점은 "연산에 사용할 데이터의 크기가 제한 될 수 있습니다."

그렇다고 꼭 단점만 있는것은 아닙니다.

"속도가 빠르다"는 장점이 있습니다.

2️⃣ **직접 주소 지정 방식(direct addressing mode)**
- 오퍼랜드 필드에 유효 주소 직접적으로 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦

![](https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%B5%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8.png?raw=true)

이 방식의 문제점은 "유효 주소를 표현할 수 있는 크기가 줄어듭니다."

다시 말해 "유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어들 수 있습니다."

3️⃣ **간접 주소 지정 방식(indirect addressing mode)**
- 오퍼랜드 필드에 유효 주소의 주소를 명시
- 앞선 주소 지정 방식들에 비해 속도가 느림
    - 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 일반적으로 느린 방식입니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%80%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8.png?raw=true)

이 방식은 "직접 주소 지정 방식"의 문제점을 극복하기 위한 방법 중 하나입니다.

"직접 주소 지정 방식"은 "연산에 사용할 데이터"를 직접적으로 명시하다보니 "유효 주소의 크기를 표현할 수 있는 데이터가 제한됩니다."

때문에 "간접 주소 지정 방식"은 "유효 주소의 주소"를 명시합니다.

그려면 "유효 주소의 크기를 충분히 표현할 수 있게 됩니다."

하지만 이 방식은 여러번 메모리에 접근을 하는 단점이 있습니다.

여기서 중요한 점 "CPU가 메모리에 접근하는 것은 굉장히 속도가 느립니다."

"따라서 메모리에 접근하는 것을 최소화하는 것이 무조건 속도면에서 좋습니다."

즉, 앞선 주소 지정 방식들에 비해 속도가 느리다는 단점이 있습니다.

4️⃣ **레지스터 주소 지정 방식(register addressing mode)**
- 연산에 사용할 데이터가 저장된 레지스터 명시.
- 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름.

![](https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8.png?raw=true)

다만, 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유합니다.

표현할 수 있는 레지스터 크기에 제한이 생길 수 있다는 점입니다.

여기서 기억해야할 지식이 있습니다.

컴퓨터 구조에서 상식과 같은 부분입니다.

**"CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠릅니다."**

메모리는 CPU 밖에 있고, 레지스터는 CPU 안에 있습니다.

상식적으로 생각해도 레지스터에 접근하는 속도가 더 빠릅니다.

이 "레지스터 주소 지정 방식"은 "직접 주소 지정 방식"과 유사하여 많이 비교가 됩니다.

"직접 주소 지정 방식"보다는 "레지스터 주소 지정 방식"이 조금 더 빠를 수 있습니다.

5️⃣ **레지스터 간접 주소 지정 방식(register indirect addressing mode)**
- 연산에 사용할 데이터를 메모리에 저장.
- 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시.

![](https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%80%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8.png?raw=true)

유효 주소를 찾는 과정이 간점 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이이자 장점이 있습니다.

메모리에 접근하는 것이 레지스터에 접근하는 것보다 더 느립니다. 그래서 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠릅니다.

---

### 정리 🥴

- **주소 지정 방식** : 연산에 사용할 데이터를 찾는 방법
- **유효 주소** : 연산에 사용할 데이터가 저장된 위치
- **대표적인 주소 지정 방식 다섯 가지**
    -  1, 즉시 주소 지정 방식 : 연산에 사용할 데이터
    -  2, 직접 주소 지정 방식: 유효 주소(메모리 주소)
    -  3, 간접 주소 지정 방식: 유효 주소의 주소
    -  4, 레지스터 주소 지정 방식: 유효 주소(레지스터 이름)
    -  5, 레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터

이 외에도 특정 주소 지정 방식들이 있습니다.

그것들은 후에 레지스터를 학습한 후에 다시 학습하도록 하겠습니다.

---

## 마무리 👨‍🏫

👉 4가지 키워드로 정리하는 핵심 포인트
- **"명령어"** 는 연산 코드와 오퍼랜드로 구성됩니다.
- **"연산 코드"** 는 명령어가 수행할 연산을 의미합니다.
- **"오퍼랜드"** 는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다.
- **"주소 지정 방식"** 은 연산에 사용할 데이터 위치를 찾는 방법입니다.

--- 
