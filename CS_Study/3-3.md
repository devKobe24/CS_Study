# 3-3 소스 코드가 명령어가 되기까지 🧑🏻‍💻

**👨‍🔬 C 언어의 컴파일 과정**

이전 포스트에서 '컴파일 언어는 컴파일러에 의해서 컴파일이되고 그 결과 목적 코드가 된다'라고 간략하게 설명했었습니다.

실제 프로그래밍 언어가 어떤 과정으로 컴파일 되는지 이번에는 직접 알아보도록 하겠습니다.

C언어로 작성한 소스 코드는 아래와 같은 과정을 거쳐서 '실행파일'이 됩니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E2%80%8Ecs.%E2%80%8E001.jpeg?raw=true"></br>

'전처리기', '컴파일러', '어셈블러', '링커' 각각에 의하여 '전처리', '컴파일', '어셈블', '링킹'이라는 과정을 거쳐서 '실행 파일'이 됩니다.

보통 컴파일러는 아래 그림과 같이 한 번에 이루어지는 경우가 많습니다.

<img src = "https://github.com/devKobe24/images/blob/main/cs2.png?raw=true"></br>

때문에 내부적인 과정(전처리, 컴파일, 어셈블, 링킹)을 모르는 경우가 많습니다.

---

## C언어 컴파일 과정 🧑🏻‍💻

1️⃣ 먼저 '전처리기'부터 알아보겠습니다.

아래 그림을 봐보겠습니다.

<img src = "https://github.com/devKobe24/images/blob/main/cs3.png?raw=true"></br>

'전처리기'를 거치게 되면 '전처리'를 거치게 되면서 '전처리된 결과물'이 나오게 됩니다.

예를 들어 C언어에서는 '소스 코드'의 확장자는 '.c'로 사용하고, '전처리된 결과물'의 확장자를 '.i'로 사용합니다.

- 전처리 과정(preprocessing)
    - 본격적으로 컴파일하기 전에 처리할 작업들
    - 외부에 선언된 다양한 소스 코드, 라이브러리 포함(e.g `#include`)
    - 프로그래밍의 편의를 위해 작성된 매크로 변환(e.g `#define`)
    - 컴파일할 영역 명식(e.g `#if, #ifdef, ...`)

2️⃣ 다음으로 살펴볼 과정은 '컴파일'입니다.

아래 그림을 봐보겠습니다.

<img src = "https://github.com/devKobe24/images/blob/main/cs4.png?raw=true"></br>

- 컴파일 과정(compiling)
    - 전처리가 완료 되어도 여전히 소스 코드. (-> 여전히 C언어로 이루어진 소스 코드)
    - 전처리 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환.

> 어셈블리어의 모습은 CPU마다 그리고 컴파일러의 종류마다 다를 수 있습니다.

3️⃣ 어셈블러에 의하여 어셈블되는 과정에 대하여 알아보겠습니다.

아래 그림을 봐보겠습니다.

<img src = "https://github.com/devKobe24/images/blob/main/cs5.png?raw=true"></br>

- 어셈블 과정(assembling)
    - 어셈블리어를 기계어로 변환
    - 목적 코드(object file)를 포함하는 목적 파일이 됨

4️⃣ 링킹(linking)에 대해 알아봅시다.
링킹에 대해 알아보기 전에 목적 파일과 실행 파일에 대해 먼저 알아보겠습니다.

**목적 파일은 실행 파일과 다릅니다.**

목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일입니다.
**그러나 목적 파일과 실행파일은 다른 파일입니다.**
**목적 파일은 링킹(linking)을 거친 이후에야 실행 파일이 됩니다.**

이제 링킹(linking)에 대해 알아봅시다.

아래 그림을 봐봅시다.

<img src = "https://github.com/devKobe24/images/blob/main/cs6.png?raw=true"></br>

예를 들어 `main.c`라는 소스 코드가 있고 `helper.c`라는 소스 코드가 있다고 가정합니다.

이 두 소스 코드를 목적 코드로 만들었습니다.

그러나 `main.c`에는 `helper.c`에 있는 내용이 꼭 필요합니다.

두 소스 코드 목적 코드가 있으니 0과 1로 이루어져 있을것입니다.

`main.c`를 실행시 실행이 되지 않습니다.

그 이유는 `helper.c`에 있는 기능들을 가져다가 사용해야하지만 `main.c` 안에는 없기 때문입니다.

때문에 `main.c` 만 실행시, 다시 말해 `main.o` 목적 코드만 실행한다면 실행이 되지 않습니다.

즉, `main.o`와 `helper.o`를 이어주는 작업이 필요합니다.

**그 작업이 바로 링킹입니다.**

<img src = "https://github.com/devKobe24/images/blob/main/cs7.png?raw=true"></br>

**이렇게 각기 다른 목적 코드를 하나의 실행 파일로서 묶어주는 작업. 즉, 연결 시켜주는 작업이 바로 링킹(linking)입니다.**

링킹(linking)까지 거치면 마침내 실행할 수 있는 실행 파일이 만들어집니다.
<img src = "https://github.com/devKobe24/images/blob/main/cs8.png?raw=true"></br>
